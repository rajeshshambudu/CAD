<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Editable 3D Floor Plan (Wall Dimensions)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{margin:0;overflow:hidden;font-family:Arial;background:#eee}
#panel{
 position:fixed;right:10px;top:10px;
 background:#fff;padding:12px;border-radius:8px;
 box-shadow:0 0 10px rgba(0,0,0,.3);width:260px
}
label{font-size:13px}
input{width:100%}
button{width:100%;margin-top:5px}
</style>
</head>
<body>

<div id="panel">
<b>Selected Wall Editor</b><br><br>

<label>Length</label>
<input type="range" id="len" min="2" max="30" step="0.5">

<label>Breadth (Thickness)</label>
<input type="range" id="br" min="0.1" max="2" step="0.1">

<label>Height</label>
<input type="range" id="ht" min="1" max="6" step="0.2">

<button onclick="topView()">Top View</button>
<button onclick="freeView()">3D View</button>

<p style="font-size:12px">
ðŸ–± Click wall to select<br>
ðŸŸ¦ Drag to move
</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/OrbitControls.js"></script>

<script>
// ================= SCENE =================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf2f2f2);

// CAMERA
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,1000);
camera.position.set(0,25,0);
camera.lookAt(0,0,0);

// RENDERER
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

// CONTROLS
const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.enableRotate = false;
controls.enableDamping = true;

// LIGHT
scene.add(new THREE.AmbientLight(0xffffff,.8));
const sun = new THREE.DirectionalLight(0xffffff,.6);
sun.position.set(10,20,10);
scene.add(sun);

// MATERIALS
const floorMat = new THREE.MeshStandardMaterial({color:0xdcdcdc});
const wallMat = new THREE.MeshStandardMaterial({color:0xffffff});

// FLOOR
scene.add(new THREE.Mesh(new THREE.BoxGeometry(40,.2,30),floorMat));

// GRID
scene.add(new THREE.GridHelper(50,50));

// WALL STORAGE
const walls = [];
let selectedWall = null;

// CREATE WALL
function createWall(l,h,b,x,z,rot=0){
 const geo = new THREE.BoxGeometry(l,h,b);
 const wall = new THREE.Mesh(geo,wallMat);
 wall.position.set(x,h/2,z);
 wall.rotation.y = rot;
 scene.add(wall);
 walls.push(wall);
}

// INITIAL WALLS
createWall(20,3,.2,0,-10);
createWall(20,3,.2,0,10);
createWall(20,3,.2,10,0,Math.PI/2);
createWall(20,3,.2,-10,0,Math.PI/2);
createWall(6,3,.2,-6,0,Math.PI/2);
createWall(6,3,.2,-4,-4);
createWall(6,3,.2,3,-4);
createWall(4,3,.2,7,2,Math.PI/2);

// RAYCAST
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// SELECT WALL
addEventListener('mousedown',e=>{
 mouse.x=(e.clientX/innerWidth)*2-1;
 mouse.y=-(e.clientY/innerHeight)*2+1;
 ray.setFromCamera(mouse,camera);
 const hit = ray.intersectObjects(walls);
 if(hit.length){
   selectedWall = hit[0].object;
   const g = selectedWall.geometry.parameters;
   len.value = g.width;
   ht.value  = g.height;
   br.value  = g.depth;
 }
});

// DRAG WALL
addEventListener('mousemove',e=>{
 if(!selectedWall) return;
 mouse.x=(e.clientX/innerWidth)*2-1;
 mouse.y=-(e.clientY/innerHeight)*2+1;
 ray.setFromCamera(mouse,camera);
 const plane = new THREE.Plane(new THREE.Vector3(0,1,0),0);
 const pos = new THREE.Vector3();
 ray.ray.intersectPlane(plane,pos);
 selectedWall.position.x = pos.x;
 selectedWall.position.z = pos.z;
});
addEventListener('mouseup',()=>selectedWall=null);

// UPDATE GEOMETRY
function updateWall(){
 if(!selectedWall) return;
 selectedWall.geometry.dispose();
 selectedWall.geometry = new THREE.BoxGeometry(
   +len.value,
   +ht.value,
   +br.value
 );
 selectedWall.position.y = ht.value/2;
}
len.oninput = updateWall;
br.oninput = updateWall;
ht.oninput = updateWall;

// VIEW MODES
function topView(){
 camera.position.set(0,25,0);
 camera.lookAt(0,0,0);
 controls.enableRotate = false;
}
function freeView(){
 camera.position.set(20,15,20);
 camera.lookAt(0,0,0);
 controls.enableRotate = true;
}

// LOOP
function animate(){
 requestAnimationFrame(animate);
 controls.update();
 renderer.render(scene,camera);
}
animate();

addEventListener('resize',()=>{
 renderer.setSize(innerWidth,innerHeight);
 camera.aspect = innerWidth/innerHeight;
 camera.updateProjectionMatrix();
});
</script>

</body>
</html>

